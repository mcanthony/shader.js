// Generated by CoffeeScript 1.6.3
var Base, Fragment, Vertex, namespace, _ref, _ref1,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

namespace = function(target, name, block) {
  var item, top, _i, _len, _ref, _ref1;
  if (arguments.length < 3) {
    _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
  }
  top = target;
  _ref1 = name.split('.');
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    item = _ref1[_i];
    target = target[item] || (target[item] = {});
  }
  return block(target, top);
};

Base = (function() {
  function Base() {}

  Base.prototype.init = function() {};

  Base.prototype.process = function() {};

  Base.prototype.compile = function() {
    var ast;
    ast = this._parse();
    ast = this._translate(ast);
    return this._generate(ast);
  };

  Base.prototype._parse = function() {
    var init_ast, init_src, process_ast, process_src;
    init_src = this.init.toString().replace("function ", "function init");
    process_src = this.process.toString().replace("function ", "function main");
    init_ast = esprima.parse(init_src).body[0];
    process_ast = esprima.parse(process_src).body[0];
    console.log(init_ast);
    console.log(process_ast);
    return [init_ast, process_ast];
  };

  Base.prototype._walk = function(node, accept) {
    var child, name, _i, _len;
    if (node instanceof Array) {
      for (_i = 0, _len = node.length; _i < _len; _i++) {
        child = node[_i];
        this._walk(child, accept);
      }
      return;
    }
    if ((node instanceof Object) && (node.type != null)) {
      if (typeof accept === "function" ? accept(node) : void 0) {
        return;
      }
      for (name in node) {
        child = node[name];
        this._walk(child, accept);
      }
      return;
    }
  };

  Base.prototype._translate = function(ast) {
    var fn, fns, symbols, _i, _len;
    symbols = [];
    fns = [];
    for (_i = 0, _len = ast.length; _i < _len; _i++) {
      fn = ast[_i];
      this._walk(fn, function(node) {
        var fn_name, param, _j, _len1, _ref;
        if (node.type !== "FunctionDeclaration") {
          return false;
        }
        fn_name = node.id.name;
        _ref = node.params;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          param = _ref[_j];
          param.orign = fn_name;
          symbols.push(param);
        }
        return true;
      });
      fns.push(fn);
    }
    console.log(symbols);
    return;
    return {
      symbols: symbols,
      fns: fns
    };
  };

  Base.prototype._generate = function(ast) {
    var glsl;
    return glsl = "";
  };

  return Base;

})();

Vertex = (function(_super) {
  __extends(Vertex, _super);

  function Vertex() {
    _ref = Vertex.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  return Vertex;

})(Base);

Fragment = (function(_super) {
  __extends(Fragment, _super);

  function Fragment() {
    _ref1 = Fragment.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  return Fragment;

})(Base);

namespace('ShaderJs', function(exports) {
  exports.Base = Base;
  exports.Fragment = Fragment;
  exports.Vertex = Vertex;
});
