// Generated by CoffeeScript 1.6.3
var Base, Fragment, Vertex, namespace, _ref, _ref1,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

namespace = function(target, name, block) {
  var item, top, _i, _len, _ref, _ref1;
  if (arguments.length < 3) {
    _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
  }
  top = target;
  _ref1 = name.split('.');
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    item = _ref1[_i];
    target = target[item] || (target[item] = {});
  }
  return block(target, top);
};

Base = (function() {
  function Base() {}

  Base.prototype.init = function() {};

  Base.prototype.process = function() {};

  Base.prototype.compile = function() {
    var ast;
    ast = this._parse();
    ast = this._translate(ast);
    return this._generate(ast);
  };

  Base.prototype._parse = function() {
    var init_ast, init_src, process_ast, process_src;
    init_src = this.init.toString().replace("function ", "function init");
    process_src = this.process.toString().replace("function ", "function main");
    init_ast = esprima.parse(init_src).body[0];
    process_ast = esprima.parse(process_src).body[0];
    console.log(init_ast);
    console.log(process_ast);
    return [init_ast, process_ast];
  };

  Base.prototype._walk = function(node, accept) {
    var child, name, _i, _len;
    if (node instanceof Array) {
      for (_i = 0, _len = node.length; _i < _len; _i++) {
        child = node[_i];
        this._walk(child, accept);
      }
      return;
    }
    if ((node instanceof Object) && (node.type != null)) {
      if (typeof accept === "function" ? accept(node) : void 0) {
        return;
      }
      for (name in node) {
        child = node[name];
        this._walk(child, accept);
      }
      return;
    }
  };

  Base.prototype._translate = function(ast) {
    var assigned, fn, fn_name, fns, param, symbols, unresolved, _i, _j, _len, _len1, _ref;
    symbols = [];
    fns = [];
    for (_i = 0, _len = ast.length; _i < _len; _i++) {
      fn = ast[_i];
      if (fn.type !== "FunctionDeclaration") {
        continue;
      }
      fn_name = fn.id.name;
      _ref = fn.params;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        param = _ref[_j];
        param.orign = fn_name;
        param.scope = 'global';
        symbols.push(param);
      }
      unresolved = {};
      this._walk(fn.body, function(body_node) {
        var declaration, _k, _len2, _ref1;
        if (body_node.type !== 'VariableDeclaration') {
          return false;
        }
        _ref1 = body_node.declarations;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          declaration = _ref1[_k];
          declaration.origin = fn_name;
          declaration.scope = 'local';
          if (declaration.init == null) {
            unresolved[declaration.id.name] = declaration;
          }
          symbols.push(declaration);
        }
        return true;
      });
      assigned = {};
      this._walk(fn.body, function(body_node) {
        var expr, sym;
        if (body_node.type !== 'ExpressionStatement') {
          return false;
        }
        expr = body_node.expression;
        if (expr.type !== 'AssignmentExpression') {
          return true;
        }
        if (expr.left.type !== 'Identifier') {
          return true;
        }
        if (assigned[expr.left.name] != null) {
          return true;
        }
        assigned[expr.left.name] = expr.left;
        sym = unresolved[expr.left.name];
        if (sym != null) {
          sym.defer_init = expr.right;
          return delete unresolved[expr.left.name];
        }
      });
      console.assert(Object.keys(unresolved).length === 0, "Not all symbols are resolved");
      fns.push(fn);
    }
    console.log(symbols);
    return;
    return {
      symbols: symbols,
      fns: fns
    };
  };

  Base.prototype._generate = function(ast) {
    var glsl;
    return glsl = "";
  };

  return Base;

})();

Vertex = (function(_super) {
  __extends(Vertex, _super);

  function Vertex() {
    _ref = Vertex.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  return Vertex;

})(Base);

Fragment = (function(_super) {
  __extends(Fragment, _super);

  function Fragment() {
    _ref1 = Fragment.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  return Fragment;

})(Base);

namespace('ShaderJs', function(exports) {
  exports.Base = Base;
  exports.Fragment = Fragment;
  exports.Vertex = Vertex;
});
