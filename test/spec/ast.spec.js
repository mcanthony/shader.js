// Generated by CoffeeScript 1.6.3
define(function(require, exports, module) {
  var Path, Util;
  Path = window.ShaderJs.Ast.Path;
  Util = require("./util");
  return exports = describe("AST Utils", function() {
    describe("Environment", function() {
      it("has namespace 'window.ShaderJs.Ast'", function() {
        return expect(window.ShaderJs.Ast != null).toBe(true);
      });
      it("has class 'Path'", function() {
        return expect(window.ShaderJs.Ast.Path != null).toBe(true);
      });
      it("has class 'Dispatcher'", function() {
        return expect(window.ShaderJs.Ast.Dispatcher != null).toBe(true);
      });
      return it("has class 'Walker'", function() {
        return expect(window.ShaderJs.Ast.Walker != null).toBe(true);
      });
    });
    describe("PathResolver", function() {
      var fn_node, path, simple_node;
      path = new Path();
      simple_node = Util.parseOne("answer = 6 * 7");
      it("resolves path with no type constraints", function() {
        var n, r, _i, _len;
        r = path.resolve(simple_node, ":>expression>left");
        expect(r.length).toEqual(3);
        for (_i = 0, _len = r.length; _i < _len; _i++) {
          n = r[_i];
          expect(n).not.toEqual(null);
        }
        expect(r[0]).toEqual(simple_node);
        expect(r[1]).toEqual(simple_node.expression);
        return expect(r[2]).toEqual(simple_node.expression.left);
      });
      it("resolves path with type constraints", function() {
        var n, p, r, _i, _len;
        p = ":ExpressionStatement>expression:AssignmentExpression>right:BinaryExpression";
        r = path.resolve(simple_node, p);
        expect(r.length).toEqual(3);
        for (_i = 0, _len = r.length; _i < _len; _i++) {
          n = r[_i];
          expect(n).not.toEqual(null);
        }
        expect(r[0]).toEqual(simple_node);
        expect(r[1]).toEqual(simple_node.expression);
        return expect(r[2]).toEqual(simple_node.expression.right);
      });
      fn_node = Util.parseOne("function foo(a, b) {}");
      it("resolves path with array accessor", function() {
        var id, n, p, r, _i, _j, _len, _len1, _ref, _results;
        p = ":FunctionDeclaration>params[]:Identifier";
        r = path.resolve(fn_node, p);
        expect(r.length).toEqual(2);
        for (_i = 0, _len = r.length; _i < _len; _i++) {
          n = r[_i];
          expect(n).not.toEqual(null);
        }
        expect(r[0]).toEqual(fn_node);
        expect(r[1]).toEqual(fn_node.params);
        expect(r[1] instanceof Array).toBe(true);
        _ref = r[1];
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          id = _ref[_j];
          _results.push(expect(id).to.toEuqal(null));
        }
        return _results;
      });
      return it("resolves path with array element accessor", function() {
        var n, p, r, _i, _len;
        p = ":FunctionDeclaration>params[0]:Identifier";
        r = path.resolve(fn_node, p);
        expect(r.length).toEqual(2);
        for (_i = 0, _len = r.length; _i < _len; _i++) {
          n = r[_i];
          expect(n).not.toEqual(null);
        }
        expect(r[0]).toEqual(fn_node);
        return expect(r[1]).toEqual(fn_node.params[0]);
      });
    });
    return describe("PathDispatcher", function() {
      it("dispatches simple map");
      it("dispatches nested map");
      return it("dispatches with return values");
    });
  });
});
